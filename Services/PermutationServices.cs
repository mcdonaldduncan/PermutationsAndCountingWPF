using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace PermutationsAndCountingWPF.Services
{
    /// <summary>
    /// Used to generate lists of permutations, partitions, and combinations
    /// </summary>
    internal class PermutationServices
    {
        CountingServices CountingService = new CountingServices();

        /// <summary>
        /// process inputs and out lists of all permutations, ordered partitions, and combinations
        /// </summary>
        /// <param name="input"></param>
        /// <param name="limit"></param>
        /// <param name="permutations"></param>
        /// <param name="ordPartitions"></param>
        /// <param name="combinations"></param>
        public void ProcessInput(string input, int limit, out List<string> permutations, out List<string> ordPartitions, out List<string> combinations)
        {
            permutations = GetPermutations(input, limit);
            ordPartitions = GetOrderedPartitions(GetPermutations(input, input.Length));
            combinations = GetCombinations(permutations, input);
        }

        /// <summary>
        /// Get permutations generates all combinations of characters given a string of characters and a limit of how many to pick
        /// Get permutations does not consider non-unique values
        /// All permutations are generated by looping through the characters and recursively generating permutations
        /// for each of those characters based off a new string of remaining characters, eventually stopping at limit
        /// </summary>
        /// <param name="characters"></param>
        /// <param name="limit"></param>
        /// <returns></returns>
        List<string> GetPermutations(string characters, int limit)
        {
            List<string> permutations = new List<string>();

            for (int i = 0; i < characters.Length; i++)
            {
                string first = characters[i].ToString();
                string remaining = characters.Remove(i, 1);

                if (limit == 1)
                {
                    permutations.Add(first);
                }
                else
                {
                    List<string> subPermutations = GetPermutations(remaining, limit - 1);

                    foreach (string subPermutation in subPermutations)
                    {
                        permutations.Add(first + subPermutation);
                    }
                }
            }

            return permutations;
        }

        /// <summary>
        /// Given permutations previously generated and character string, generate a lookup dictionary and calculate scores for all 
        /// permutations, adding any with new scores to the combination list returned
        /// </summary>
        /// <param name="permutations"></param>
        /// <param name="characters"></param>
        /// <returns></returns>
        List<string> GetCombinations(List<string> permutations, string characters)
        {
            List<string> combinations = new List<string>();
            List<int> scoresFound = new List<int>();

            Dictionary<char, int> lookupDict = CountingService.GenerateLookupDict(characters);

            foreach (var permutation in permutations)
            {
                int score = CountingService.CalculatePermScore(permutation, lookupDict);

                if (!scoresFound.Contains(score))
                {
                    scoresFound.Add(score);
                    combinations.Add(permutation);
                }
            }

            return combinations;
        }

        /// <summary>
        /// Get Ordered Partitions takes in the previously generated list of permutations and
        /// iterates over the list to find all unique permutations
        /// </summary>
        /// <param name="permutations"></param>
        /// <returns></returns>
        List<string> GetOrderedPartitions(List<string> permutations)
        {
            List<string> partitions = new List<string>();

            foreach (var permutation in permutations)
            {
                if (!partitions.Contains(permutation))
                {
                    partitions.Add(permutation);
                }
            }

            return partitions;
        }
    }
}
